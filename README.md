lua-newstate
====

newstate module to run scripts in the new lua_State.

## Installation

```sh
luarocks install newstate
```


## Return Code

- `ERRARGS`: invalid argument passed.
- `ERRRUN:` a runtime error.
- `ERRSYNTAX`: syntax error.
- `ERRMEM`: memory allocation error. For such errors, Lua does not call the message handler.
- `ERRERR`: error while running the message handler.
- `ERRFILE`: a file-related error; e.g., it cannot open or read the file.

**the following code is only defined in Lua version 5.2 and 5.3**

- `ERRGCMM`: error while running a `__gc` metamethod. (This error typically has no relation with the function being called. It is generated by the garbage collector.)


## Create a newstate

### L = new( [openlibs] )

returns the newstate, or nil to memory allocation error.

**Parameters**

- `openlibs:boolean`: opens all standard Lua libraries into the newstate. (default `true`)

**Returns**

1. `L:newstate`: new newstate.


## Run the script in newstate

### ok, err, rc = L:dofile( filename, ... )
### ok, err, rc = L:dostring( str, ... )

loads and runs the given filename or string.

**Parameters**

- `filename:string`: pathname of the script file.
- `str:string`: the script source code.
- `...`: arguments for the script. only the following types of arguments are allowed;
  - `LAU_TNIL`
  - `LUA_TBOOLEAN`
  - `LUA_TLIGHTUSERDATA`
  - `LUA_TNUMBER`
  - `LUA_TSTRING`
  - `LUA_TTABLE`

**Returns**

1. `ok:boolean`: true on success, or false on failure.
2. `err:string`: error message on failure.
3. `rc:number`: [return code](#return-code).


#### Usage

run the passed string as a function in newstate.

```lua
local newstate = require('newstate')
local L = newstate.new()
assert(L:dostring([[
    local dump = require('dump')
    print('hello newstate world!')
    print(dump({...}))
    print('done')
]], 'foo', nil, 1, true, 0.5, '', false, {
    'array value',
    key = 'value',
    num = 3.1415,
    boolean = true,
    table = {qux = {quux = 'value'}},
}))

-- above code will output the following; 
--[[ 
hello newstate world!
{
    [1] = "foo",
    [3] = 1,
    [4] = true,
    [5] = 0.5,
    [6] = "",
    [7] = false,
    [8] = {
        [1] = "array value",
        boolean = true,
        key = "value",
        num = 3.1415,
        table = {
            qux = {
                quux = "value"
            }
        }
    }
}
done
]]
```

also, you can pass the binary chunk.

```lua
local newstate = require('newstate')
local L = newstate.new()
local f = function(...)
    local dump = require('dump')
    print('hello newstate world!')
    print(dump({...}))
    print('done')
end
assert(L:dostring(string.dump(f), 'foo', nil, 1, true, 0.5, '', false, {
    'array value',
    key = 'value',
    num = 3.1415,
    boolean = true,
    table = {qux = {quux = 'value'}},
}))
]]
```

## Preloading the script in newstate

### rc, err = L:loadfile( filename )
### rc, err = L:loadstring( str )

preloads the given filename or string.

**Parameters**

- `filename:string`: pathname of the script file.
- `str:string`: the script source code.

**Returns**

1. `ok:boolean`: true on success, or false on failure.
2. `err:string`: error message on failure.
3. `rc:number`: [return code](#return-code).


#### Usage

preload the script and then run it.

```lua
local newstate = require('newstate')
local L = newstate.new()
assert(L:loadstring([[
    local dump = require('dump')
    print('hello newstate world!')
    print(dump({...}))
    print('done')
]]))
```


## Runs the preloaded script

### rc, err = L:run( ... )

runs the preloaded script.

**Parameters**

- `...`: arguments for the script. only the following types of arguments are allowed;
  - `LAU_TNIL`
  - `LUA_TBOOLEAN`
  - `LUA_TLIGHTUSERDATA`
  - `LUA_TNUMBER`
  - `LUA_TSTRING`
  - `LUA_TTABLE`

**Returns**

1. `ok:boolean`: true on success, or false on failure.
2. `err:string`: error message on failure.
3. `rc:number`: [return code](#return-code).


#### Usage

runs the preloaded script.


```lua
local newstate = require('newstate')
local L = newstate.new()
local f = function(...)
    print(...)
end
assert(L:loadstring(string.dump(f)))
for i = 1, 2 do
    assert(L:run('call', i))
end
print('done')

--[[
-- above code will output the following; 
call	1
call	2
done
]]
```
