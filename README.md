lua-newstate
====

newstate module to run scripts in the new lua_State.

## Installation

```sh
luarocks install newstate
```


## Return Code

- `ERRINVAL`: invalid value type.
- `ERRRUN:` a runtime error.
- `ERRSYNTAX`: syntax error.
- `ERRMEM`: memory allocation error. For such errors, Lua does not call the message handler.
- `ERRERR`: error while running the message handler.
- `ERRFILE`: a file-related error; e.g., it cannot open or read the file.

**the following code is only defined in Lua version 5.2 and 5.3**

- `ERRGCMM`: error while running a `__gc` metamethod. (This error typically has no relation with the function being called. It is generated by the garbage collector.)


## GC Code

- `GCSTOP`: stops the garbage collector.
- `GCRESTART`: restarts the garbage collector.
- `GCCOLLECT`: performs a full garbage-collection cycle.
- `GCCOUNT`: returns the current amount of memory (in Kbytes) in use by Lua.
- `GCCOUNTB`: returns the remainder of dividing the current amount of bytes of memory in use by Lua by 1024.
- `GCSTEP`: performs an incremental step of garbage collection. the step size is controlled by arg (`int stepsize`).
- `GCSETPAUSE`: sets arg (`int steppause`) as the new value for the pause of the collector and returns the previous value of the pause.
- `GCSETSTEPMUL`: sets arg (`int stepmul`) as the new value for the step multiplier of the collector (see ยง2.5). Returns the previous value for step.

**the following code is defined in Lua version 5.2**

- `GCSETMAJORINC`: 

**the following code is defined in Lua version 5.3 or later**

- `GCISRUNNING`: returns a boolean that tells whether the collector is running.


**the following code is defined in Lua version 5.2 and 5.4 or later**

- `GCGEN`: changes the collector to incremental mode with the given parameters (`int pause`, `int stepmul`, `int stepsize`). returns the previous mode (`GCGEN` or `GCINC`).
- `GCINC`: changes the collector to generational mode with the given parameters (`int minormul`, `int majormul`). Returns the previous mode (`GCGEN` or `GCINC`).


## Exchangeable Values

only the following types of values are allowed as arguments or return values.

- `LAU_TNIL`
- `LUA_TBOOLEAN`
- `LUA_TLIGHTUSERDATA`
- `LUA_TNUMBER`
- `LUA_TSTRING`
- `LUA_TTABLE`

methods return an `ERRINVAL` error if the argument or result value type is not an exchangeable value type.

## Create a newstate

### L = new( [openlibs] )

returns the newstate, or nil to memory allocation error.

**Parameters**

- `openlibs:boolean`: opens all standard Lua libraries into the newstate. (default `true`)

**Returns**

1. `L:newstate`: new newstate.


## Run the script in newstate

### ok [, ...] = L:dofile( filename, ... )
### ok [, ...]  = L:dostring( str, ... )

loads and runs the given filename or string.

**Parameters**

- `filename:string`: pathname of the script file.
- `str:string`: the script source code.
- `...`: arguments ([exchangeable values](#exchangeable-values)) for the script. 

**Returns**

1. `ok:boolean`: true on success, or false on failure.
2. `...`: on success it returns all results ([exchangeable values](#exchangeable-values)) from the call, on failure it returns the following results; 
    1. `err:string`: error message on failure.
    2. `rc:number`: [return code](#return-code).


#### Usage

run the passed string as a function in newstate.

```lua
local newstate = require('newstate')
local dump = require('dump')
local L = newstate.new()
local f = [[
    local dump = require('dump')
    print('hello newstate world!')
    print(dump({...}))
    print('done')
    return ...
]]
local ret = {
    assert(L:dostring(f, 'foo', nil, 1, true, 0.5, '', false, {
        'array value',
        key = 'value',
        num = 3.1415,
        boolean = true,
        table = {qux = {quux = 'value'}},
    }))}
print('returns', dump(ret))

-- above code will output the following; 
--[[ 
hello newstate world!
{
    [1] = "foo",
    [3] = 1,
    [4] = true,
    [5] = 0.5,
    [6] = "",
    [7] = false,
    [8] = {
        [1] = "array value",
        boolean = true,
        key = "value",
        num = 3.1415,
        table = {
            qux = {
                quux = "value"
            }
        }
    }
}
done
returns	{
    [1] = true,
    [2] = "foo",
    [4] = 1,
    [5] = true,
    [6] = 0.5,
    [7] = "",
    [8] = false,
    [9] = {
        [1] = "array value",
        boolean = true,
        key = "value",
        num = 3.1415,
        table = {
            qux = {
                quux = "value"
            }
        }
    }
}
]]
```

also, you can pass the binary chunk.

```lua
local newstate = require('newstate')
local L = newstate.new()
local f = function(...)
    local dump = require('dump')
    print('hello newstate world!')
    print(dump({...}))
    print('done')
end
assert(L:dostring(string.dump(f), 'foo', nil, 1, true, 0.5, '', false, {
    'array value',
    key = 'value',
    num = 3.1415,
    boolean = true,
    table = {qux = {quux = 'value'}},
}))
]]
```

## Preloading the script in newstate

### ok, err, rc = L:loadfile( filename )
### ok, err, rc = L:loadstring( str )

preloads the given filename or string.

**Parameters**

- `filename:string`: pathname of the script file.
- `str:string`: the script source code.

**Returns**

1. `ok:boolean`: true on success, or false on failure.
2. `err:string`: error message on failure.
3. `rc:number`: [return code](#return-code).


#### Usage

preload the script and then run it.

```lua
local newstate = require('newstate')
local L = newstate.new()
assert(L:loadstring([[
    local dump = require('dump')
    print('hello newstate world!')
    print(dump({...}))
    print('done')
]]))
```


## Runs the preloaded script

### ok [, ...] = L:run( ... )

runs the preloaded script.

**Parameters**

- `...`: arguments ([exchangeable values](#exchangeable-values)) for the script. 

**Returns**

1. `ok:boolean`: true on success, or false on failure.
2. `...`: on success it returns all results ([exchangeable values](#exchangeable-values)) from the call, on failure it returns the following results; 
    1. `err:string`: error message on failure.
    2. `rc:number`: [return code](#return-code).


#### Usage

runs the preloaded script.


```lua
local newstate = require('newstate')
local L = newstate.new()
local f = function(...)
    print(...)
end
assert(L:loadstring(string.dump(f)))
for i = 1, 2 do
    assert(L:run('call', i))
end
print('done')

--[[
-- above code will output the following; 
call	1
call	2
done
]]
```


## Garbage Collection

### res = L:gc( arg, ... )

performs the specified task of the garbage collector.

**Parameters**

- `arg`: [gc code](#gc-code).
- `...`: arguments for gc code. 

**Returns**

1. `res`: if the argument is `LUA_GCISRUNNING`, returns a `boolean`, otherwise it returns an `integer`.


#### Usage

performs a full gc cycle.

```lua
local newstate = require('newstate')
local L = newstate.new()
L:gc(newstate.GCOLLECT)
```
